package dulithm.hackerrank.challenges;

import java.util.List;

/**
 * @author Dulith
 * @see <a href="https://www.hackerrank.com/challenges/coin-change/problem">hackerrank</a>
 */
public class CoinChange {
    /**
     * @param n target value that we need to get the coin combinations
     * @param c coins list
     * @return number of ways
     * <br/><i>Had to get help from the forum for this one ;-)</i>
     *
     * <h3>First step</h3>
     * <ul>
     * <li>assume you have to create 10 using only one coin whose value is 2</li>
     * <li>we create a "ways" array with 11 values (ways from 0 to 10)</li>
     * <li>0 can be created even without coins so 1st element of the array would be 1 initially</li>
     * <li>array would be <code>[1,0,0,0,0,0,0,0,0,0,0]</code></li>
     * </ul>
     *
     * <h3>Consider 1st coin</h3>
     * <ul>
     * <li>iterate from coin value to target value (2 to 10).</li>
     * <li>2 can be created using coin 2 but what we do is (2 - 2) = 0 add ways[0] to current =><br/>
     *   <code>ways[2] += ways[0] => 1</code></li>
     * <li>3 cannot be created using coin 2, see, using the same way (3 - 2) = 1 add ways[1] to current =><br/>
     *   <code> ways[3] += ways[1] => 0</code></li>
     * <li>4 can be created using coin 2, what we do is  (4 - 2) = 2 add ways[2] to current =><br/>
     *   <code>ways[4] += ways[2] => 1</code></li>
     * <li>...</li>
     * <li>for each multiple of 2 (even numbers), it will continue this pattern and for 10 it will be =><br/>
     *   <code>ways[10] += ways[8] => 1</code></li>
     * <li>array would be <code>[1,0,1,0,1,0,1,0,1,0,1]</code></li>
     * <p>the above array idicates that using only coin 2, numbers 2,4,6,8 and 10 can be created with only 1 pattern.</p>
     * </ul>
     *
     * <h3>And the next coin</h3>
     * <ul>
     * <li>let's say now we have a new coin 5, coins = [2, 5]</li>
     * <li>again, iterate from coin value to target value (5 to 10)</li>
     * <li>5 can be created using coin 5, with the previous method (5 - 5) = 0 we can get the ways =><br/>
     *   <code>ways[5] += ways[0] => 1</code></li>
     * <li>for 6, (6 - 5) = 1 =><br/>
     *    <code>ways[6] += ways[1] => 1</code></li>
     * <li>for 7, (7 - 5) = 2 =><br/>
     *    <code>ways[7] += ways[2] => 0</code></li>
     * <li>...</li>
     * <li>and for 10, (10 - 5) = 5 =><br/>
     *    <code>ways[10] += ways[5]=> 2</code></li>
     * <li>array would be <code>[1,0,1,0,1,1,1,0,1,0,2]</code></li>
     * <p>notice how 10 was affected by this new coin 5, => 2,2,2,2,2 and 5,5
     * every multiple of 5 would cumulatively add additional 1 way of coin combinations</p>
     * </ul>
     *
     * <h3>More coins?</h3>
     * <ul>
     * <li>if we add more coins into the coin array this cumulative addition would occur</li>
     * <li>eg if we add 3 to the array [2, 5, 3]</li>
     * <li>array would be <code>[1,0,1,1,1,1,2,0,1,2,2]</code></li>
     * <p>notice that ways[9] is 2, this is because ways[9 - 3] is 2.
     * which means this method takes care of the previously used coins accordingly => 2,2,2,3 and 3,3,3</p>
     * </ul>
     */
    public long getWays(int n, List<Long> c) {
        // ways of creating combinations with given coins, for ever number that is between 0 and target value (n)
        long[] ways = new long[n + 1];
        ways[0] = 1L; // first all the ways are 0 for evey number, except for 0, which can be created without coins;
        for (Long coin : c) { // for every coin in coins list
            // from coin to target value (numbers less than coin value cannot be created with this new coin)
            for (Long i = coin; i <= n; i++) {
                // add the new combinations that are generated by the new coin to the previous combinations
                ways[i.intValue()] += ways[(int) (i - coin)];
            }
        }
        return ways[n];
    }
}
